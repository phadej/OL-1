-- |
--
-- The code here is a modification of part of @unification-fd@ package.
--
-- @
-- Copyright (c) 2007, 2008, 2011, 2012, 2013, 2014, wren gayle romano.
-- ALL RIGHTS RESERVED.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions
-- are met:
--
--     * Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     * Redistributions in binary form must reproduce the above
--       copyright notice, this list of conditions and the following
--       disclaimer in the documentation and/or other materials provided
--       with the distribution.
--
--     * Neither the name of the copyright holders nor the names of
--       other contributors may be used to endorse or promote products
--       derived from this software without specific prior written
--       permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-- FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-- COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-- BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-- CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-- LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-- ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-- POSSIBILITY OF SUCH DAMAGE.
-- @
--
module Control.Unification.Rigid (
    -- * Term
    UTerm (..),
    UTermF (..),
    thaw,
    -- * Unifiable
    Unifiable (..),
    -- * Errors
    --
    -- | There are three classes, as we need different type variables.
    Fallible (..),
    RigidFallible (..),
    RigidFallibleAll (..),
    -- * Monad
    Unify,
    runUnify,
    freeVar,
    -- * Variable
    MetaVar (..),
    Variable,
    RigidVariable,
    -- * Unification
    unify,
    applyBindings,
    applyBindingsAll,
    withRigid,
    )where

import Control.Monad.Except      (ExceptT (..), MonadError (..), runExceptT)
import Control.Monad.State
       (MonadState (..), State, StateT (..), evalState, evalStateT, gets,
       modify', runState)
import Control.Monad.Trans.Class (lift)
import Data.Functor.Classes
       (Eq1 (..), Show1 (..), eq1, showsPrec1, showsUnaryWith)
import Data.Functor.Foldable
import Data.Functor.Identity     (Identity (..))
import Data.Traversable          (for)

import qualified Data.IntMap as IM

-------------------------------------------------------------------------------
-- MetaVar
-------------------------------------------------------------------------------

-- | Unification, meta variables.
newtype MetaVar = MetaVar Int
  deriving (Eq, Ord, Show)

-- | Class of variables.
class Eq v => Variable v where
    mkMetaVar     :: Int -> v
    matchMetaVar' :: v -> Maybe Int

-- | Rigid variables has a version of `matchMetaVar'` which tells the name of
-- the rigid variable.
class Variable v => RigidVariable n v where
    matchMetaVar :: v -> Either n Int

instance Variable MetaVar where
    mkMetaVar                 = MetaVar
    matchMetaVar' (MetaVar i) = Just i

instance RigidVariable n MetaVar where
    matchMetaVar (MetaVar i) = Right i

instance (Eq n, Variable v) => Variable (Either n v) where
    mkMetaVar     = Right . mkMetaVar
    matchMetaVar' = either (const Nothing) matchMetaVar'

instance (Eq n, RigidVariable n v) => RigidVariable n (Either n v) where
    matchMetaVar (Left n)  = Left n
    matchMetaVar (Right v) = matchMetaVar v

-------------------------------------------------------------------------------
-- Term
-------------------------------------------------------------------------------

-- | The type of terms generated by structures t over variables v.
-- The structure type should implement 'Unifiable' and the variable type should implement 'Variable' and 'RigidVariable'.
--
data UTerm t v
    = UVar  !v               -- ^ A unification variable.
    | UTerm !(t (UTerm t v)) -- ^ Some structure containing subterms.

-- | Embed a pure term as a mutable term.
thaw :: Recursive t => t -> UTerm (Base t) v 
thaw = hoist UTermF

instance Functor t => Functor (UTerm t) where
    fmap f (UVar  v) = UVar  (f v)
    fmap f (UTerm t) = UTerm (fmap (fmap f) t)

instance Foldable t => Foldable (UTerm t) where
    foldMap f (UVar  v) = f v
    foldMap f (UTerm t) = foldMap (foldMap f) t

instance Traversable t => Traversable (UTerm t) where
    traverse f (UVar  v) = UVar  <$> f v
    traverse f (UTerm t) = UTerm <$> traverse (traverse f) t

instance (Eq1 t, Eq v) => Eq (UTerm t v) where
    UVar v  == UVar v'  = v == v'
    UTerm t == UTerm t' = liftEq (==) t t'

    _ == _ = False

instance (Show1 t, Show v) => Show (UTerm t v) where
    showsPrec d (UVar v) = showsUnaryWith
        showsPrec
        "UVar" d v
    showsPrec d (UTerm t) = showsUnaryWith
        (liftShowsPrec showsPrec showList)
        "UTerm" d t

-- | 'Base' functor of 'UTerm'.
data UTermF t v a
    = UVarF !v
    | UTermF !(t a)
  deriving (Functor, Foldable, Traversable)

type instance Base (UTerm t v) = UTermF t v

instance Functor t => Recursive (UTerm t v) where
    project (UVar v)  = UVarF v
    project (UTerm t) = UTermF t

instance Functor t => Corecursive (UTerm t v) where
    embed (UVarF v)  = UVar v
    embed (UTermF t) = UTerm t

instance (Eq1 t, Eq v) => Eq1 (UTermF t v) where
    liftEq _eq (UVarF v)  (UVarF v')  = v == v'
    liftEq  eq (UTermF t) (UTermF t') = liftEq eq t t'
    liftEq _ _ _ = False

instance (Show1 t, Show v) => Show1 (UTermF t v) where
    liftShowsPrec _ _ d (UVarF v) = showsUnaryWith
        showsPrec
        "UVarF" d v
    liftShowsPrec sp sl d (UTermF t) = showsUnaryWith
        (liftShowsPrec sp sl)
        "UTermF" d t

instance (Eq1 t, Eq v, Eq a) => Eq (UTermF t v a) where (==) = eq1
instance (Show1 t, Show v, Show a) => Show (UTermF t v a) where showsPrec = showsPrec1

-------------------------------------------------------------------------------
-- Unifiable
-------------------------------------------------------------------------------

-- | An implementation of syntactically unifiable structure. 
class Traversable t => Unifiable t where
    -- | Simpler version of 'zipMatch'.
    zipMatch' :: t a -> t a -> Maybe (t (a, a))
    zipMatch' a b = fmap (fmap (either (\x -> (x,x)) id)) (zipMatch a b)

    -- | Perform one level of equality testing for terms.
    zipMatch :: t a -> t a -> Maybe (t (Either a (a, a)))
    zipMatch a b = fmap (fmap Right) (zipMatch' a b)

    {-# MINIMAL zipMatch | zipMatch' #-}

-------------------------------------------------------------------------------
-- Error
-------------------------------------------------------------------------------

class Variable v => Fallible t v e where
    -- | A cyclic term was encountered
    occursFailure        :: v -> UTerm t v -> e

    -- | The top-most level of the terms do not match.
    mismatchFailure      :: t (UTerm t v) -> t (UTerm t v) -> e

class RigidFallible n e where
    -- | Rigid variables compared 
    rigidMismatchFailure :: n -> n -> e

    -- | Rigid variable escaping its scope ('withRigid').
    escapingRigidFailure :: n -> e

class (Fallible t v e, RigidFallible n e, RigidVariable n v) => RigidFallibleAll n t v e where
    -- | Trying to unify rigid variable with a term.
    rigidBindFailure     :: n -> t (UTerm t v) -> e

-------------------------------------------------------------------------------
-- Basic methods
-------------------------------------------------------------------------------

lookupVar
    :: (Variable v, RigidFallible n e)
    => v -> Unify n e t v (Maybe (UTerm t v))
lookupVar v = case matchMetaVar' v of
    Nothing  -> return Nothing
    Just i -> Unify $ do
        m <- gets (IM.lookup i . varBindings)
        for m $ \m' -> case m' of
            Left sko -> throwError $ escapingRigidFailure sko
            Right t  -> return t

-- | Generate a new free variable guaranteed to be fresh in 'Unify'.
freeVar :: Variable v => Unify n e t v v
freeVar = Unify $ do
    ibs <- get
    let v = nextFreeVar ibs
    if  v == maxBound
        then error "freeVar: no more variables!"
        else do
            put $ ibs { nextFreeVar = v+1 }
            return $ mkMetaVar v

bindVar
    :: forall n e t v. (RigidFallibleAll n t v e, RigidVariable n v)
    => v -> UTerm t v -> Unify n e t v ()
bindVar v t = case matchMetaVar v :: Either n Int of
    Left n  -> case t of
        UVar _   -> return () -- this is not right
        UTerm t' -> throwError $ rigidBindFailure n t'
    Right i -> Unify $ do
        ibs <- get
        let bs' = IM.insert i (Right t) (varBindings ibs)
        put $ ibs { varBindings = bs' }

-------------------------------------------------------------------------------
-- Unification
-------------------------------------------------------------------------------

semiprune
    :: (RigidFallibleAll n t v e, RigidVariable n v)
    => UTerm t v -> Unify n e t v (UTerm t v)
semiprune t0'@(UTerm _ )  = return t0'
semiprune t0'@(UVar  v0') = loop t0' v0' where
    -- We pass the @t@ for @v@ in order to add just a little more sharing.
    loop t0 v0 = do
        mb <- lookupVar v0
        case mb of
            Nothing -> return t0
            Just t  ->
                case t  of
                UTerm _  -> return t0
                UVar  v  -> do
                    finalVar <- loop t v
                    v0 `bindVar` finalVar
                    return finalVar

-- | Unify two terms, or throw an error with an explanation of why unification failed.
unify
    :: forall t v e n. (Unifiable t, RigidFallibleAll n t v e)
    => UTerm t v -> UTerm t v -> Unify n e t v (UTerm t v)
unify tl0' tr0' = evalStateT (loop tl0' tr0') IM.empty
    where
    {-# INLINE (=:) #-}
    v =: t = lift $ v `bindVar` t

    equalVars :: v -> v -> Unify n e t v ()
    equalVars a b
        | a == b    = return ()
        | otherwise = case (matchMetaVar a :: Either n Int, matchMetaVar b) of
            (Right _, _)       -> bindVar a (UVar b)
            (_,       Right _) -> bindVar b (UVar a)
            (Left a', Left b') -> throwError $ rigidMismatchFailure a' b'

    loop :: UTerm t v -> UTerm t v -> StateT (IM.IntMap (t (UTerm t v))) (Unify n e t v) (UTerm t v)
    loop tl00 tr00 = do
        tl0 <- lift $ semiprune tl00
        tr0 <- lift $ semiprune tr00
        case (tl0, tr0) of
            (UVar vl, UVar vr)
                | vl == vr  -> return tr0
                | otherwise -> do
                    mtl <- lift $ lookupVar vl
                    mtr <- lift $ lookupVar vr
                    case (mtl, mtr) of
                        (Nothing, Nothing) -> do lift (equalVars vl vr) ; return tr0
                        (Nothing, Just _ ) -> do vl =: tr0 ; return tr0
                        (Just _ , Nothing) -> do vr =: tl0 ; return tl0
                        (Just (UTerm tl), Just (UTerm tr)) -> do
                            t <- localState $ do
                                vl `seenAs` tl
                                vr `seenAs` tr
                                match tl tr
                            vr =: t
                            vl =: tr0
                            return tr0
                        _ -> error _impossible_unify

            (UVar vl, UTerm tr) -> do
                t <- do
                    mtl <- lift $ lookupVar vl
                    case mtl of
                        Nothing         -> return tr0
                        Just (UTerm tl) -> localState $ do
                            vl `seenAs` tl
                            match tl tr
                        _ -> error _impossible_unify
                vl =: t
                return tl0

            (UTerm tl, UVar vr) -> do
                t <- do
                    mtr <- lift $ lookupVar vr
                    case mtr of
                        Nothing         -> return tl0
                        Just (UTerm tr) -> localState $ do
                            vr `seenAs` tr
                            match tl tr
                        _ -> error _impossible_unify
                vr =: t
                return tr0

            (UTerm tl, UTerm tr) -> match tl tr

    match tl tr =
        case zipMatch tl tr of
        Nothing  -> lift . Unify . throwError $ mismatchFailure tl tr
        Just tlr -> UTerm <$> traverse loop_ tlr

    loop_ (Left  t)       = return t
    loop_ (Right (tl,tr)) = loop tl tr

-- | Apply the current bindings from the monad so that any remaining variables in the result must, therefore, be free.
applyBindings :: (Traversable t, RigidFallibleAll n t v e) => UTerm t v -> Unify n e t v (UTerm t v)
applyBindings = fmap runIdentity . applyBindingsAll . Identity

-- | Same as 'applyBindings', but works on several terms simultaneously.
applyBindingsAll
    :: forall t s v e n. (Traversable s, Traversable t, RigidFallibleAll n t v e)
    => s (UTerm t v) -> Unify n e t v (s (UTerm t v))
applyBindingsAll ts0 = evalStateT (traverse loop ts0) IM.empty where
    loop :: UTerm t v -> StateT (IM.IntMap (Either (UTerm t v) (UTerm t v))) (Unify n e t v) (UTerm t v)
    loop t0_ = do
        t0 <- lift $ semiprune t0_
        case t0 of
            UTerm t -> UTerm <$> traverse loop t
            UVar  v -> case matchMetaVar' v of
                Nothing -> return t0
                Just i  -> do
                    mb <- IM.lookup i <$> get
                    case mb of
                        Just (Right t) -> return t
                        Just (Left  t) -> lift . throwError $ occursFailure v t
                        Nothing -> do
                            mb' <- lift $ lookupVar v
                            case mb' of
                                Nothing -> return t0
                                Just t  -> do
                                    modify' . IM.insert i $ Left t
                                    t' <- loop t
                                    modify' . IM.insert i $ Right t'
                                    return t'

_impossible_unify :: String
{-# NOINLINE _impossible_unify #-}
_impossible_unify = "unify: the impossible happened"

seenAs
    :: forall n e t v. (Variable v, Fallible t v e)
    => v
    -> t (UTerm t v) -- ^
    -> StateT (IM.IntMap (t (UTerm t v))) (Unify n e t v) () -- ^
{-# INLINE seenAs #-}
seenAs v0 t0 = case matchMetaVar' v0 of
    Nothing -> return ()
    Just i  -> do
        seenVars <- get
        case IM.lookup i seenVars of
            Just t  -> lift . Unify . throwError $ occursFailure v0 (UTerm t)
            Nothing -> put $! IM.insert i t0 seenVars

-------------------------------------------------------------------------------
-- Skolem
-------------------------------------------------------------------------------

-- | Introduce a scope with one new rigid variable.
withRigid :: Traversable t => Unify n e t (Either n v) a -> Unify n e t v a
withRigid (Unify m) = Unify $ ExceptT $ StateT $ \st0 -> do
    let (x, st1) = runState (runExceptT m) (fmap Right st0)
        vb       = fmap (>>= sequence) (varBindings st1)
    return (x, st1 { varBindings = vb })

-------------------------------------------------------------------------------
-- Monad
-------------------------------------------------------------------------------

data St n t v = St
    { nextFreeVar :: {-# UNPACK #-} !Int
    , varBindings :: IM.IntMap (Either n (UTerm t v))
    }
  deriving Functor

emptySt :: St n t v
emptySt = St minBound IM.empty

-- | Unification monad.
--
-- Parameters:
--
-- * @n@ - name of rigid variables. Most likely you want to use @()@, or similar /irrelevant/ @n1 == n2 = True@ type.
--
-- * @e@ - error type
--
-- * @t@ - term type
--
-- * @v@ - variable type (you probably want to start with 'MetaVar').
--
newtype Unify n e t v a = Unify { unUnify :: ExceptT e (State (St n t v)) a }
  deriving newtype (Functor, Applicative, Monad, MonadError e)

-- | Run unification.
--
-- Note: you might need to do 'applyBindings' to your result in the monad.
runUnify :: Unify n e t v a -> Either e a
runUnify m = evalState (runExceptT (unUnify m)) emptySt

-------------------------------------------------------------------------------
-- Misc
-------------------------------------------------------------------------------

-- | Run a state action and undo the state changes at the end.
localState :: (MonadState s m) => m a -> m a
{-# INLINE localState #-}
localState m = do
    s <- get
    x <- m
    put s
    return x
